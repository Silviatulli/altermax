# -*- coding: utf-8 -*-
"""Minimax_Game.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fNbyWfLYOO0ghZ6pDlShVqbzNmABT9OJ
"""

import os
import sys
import time
import string
import copy
import numpy as np
import pdb
import random

GAME_MAX_CELL_X = 5
GAME_MAX_CELL_Y = 1
action_dic = {'up': 0, 'down': 1, 'left': 2, 'right': 3, 'up_left': 4, 'up_right': 5, 'down_left': 6, 'down_right': 7}
player_type_dic = {'min': 0, 'max': 1}
ball_initial_pos = {0: {0: [GAME_MAX_CELL_X, 1], 1: [GAME_MAX_CELL_X, 0]}, 1: {0: [0, 1], 1: [0, 0]}}


# define the cell
class Board(object):
    def __init__(self):
        self.board = np.array([[1, 2, 10, 20, 100, 200], [4, 8, 40, 80, 400, 800]]).T

    # Get coordinates from the board by the selected value
    def get_pos(self, value):
        pos = np.where(self.board == value)
        return [int(pos[0]), int(pos[1])]

    # Get value in board from posiion
    def get_value(self, pos):
        return self.board[pos[0], pos[1]]


# define the players
class Player(object):
    def __init__(self, player_type, ballsAmount):
        self.score = 0
        self.player_type = player_type
        self.balls = []

        for i in range(ballsAmount):
            newBall = Ball(id=i, player_id=player_type, pos=ball_initial_pos[player_type][i])
            self.balls.append(newBall)


# define the balls
class Ball(object):
    def __init__(self, id, player_id, pos):
        self.id = id
        self.player_id = player_id
        self.pos = pos

    def move(self, action):
        if action == 0:
            if self.pos[1] < GAME_MAX_CELL_Y:
                self.pos[1] += 1
            else:
                # print('invalid action - Cannot go up')
                return None
        elif action == 1:
            if self.pos[1] > 0:
                self.pos[1] -= 1
            else:
                # print('invalid action - Cannot go down')
                return None
        elif action == 2:
            if self.pos[0] < GAME_MAX_CELL_X and self.player_id == 1:
                self.pos[0] += 1
            else:
                # print('invalid action - Cannot go left')
                return None
        elif action == 3:
            if self.pos[0] > 0 and self.player_id == 0:
                self.pos[0] -= 1
            else:
                # print('invalid action - Cannot go right')
                return None
        elif action == 4:
            if self.pos[1] < GAME_MAX_CELL_Y and self.pos[0] < GAME_MAX_CELL_X and self.player_id == 1:
                self.pos[1] += 1
                self.pos[0] += 1
            else:
                # print('invalid action - Cannot go up_left')
                return None
        elif action == 5:
            if self.pos[1] < GAME_MAX_CELL_Y and self.pos[0] > 0 and self.player_id == 0:
                self.pos[1] += 1
                self.pos[0] -= 1
            else:
                # print('invalid action - Cannot go up_right')
                return None
        elif action == 6:
            if self.pos[1] > 0 and self.pos[0] < GAME_MAX_CELL_X and self.player_id == 1:
                self.pos[0] += 1
                self.pos[1] -= 1
            else:
                # print('invalid action - Cannot go down_left')
                return None
        elif action == 7:
            if self.pos[1] > 0 and self.pos[0] > 0 and self.player_id == 0:
                self.pos[0] -= 1
                self.pos[1] -= 1
            else:
                # print('invalid action - Cannot go down_right')
                return None
        else:
            print('invalid action')
            return None
        return self.pos


# define the gameManager
class GameManager(object):
    def __init__(self):
        # Create board
        self.board = Board()

        # Create players
        min_player = Player(player_type=player_type_dic['min'], ballsAmount=2)
        max_player = Player(player_type=player_type_dic['max'], ballsAmount=2)
        self.players = [min_player, max_player]

        # Update scores
        self.update_scores()

    def update_scores(self):

        # For each player
        for player in self.players:

            updated_score = 0
            # Check where the balls are and get the score:
            for ball in player.balls:
                updated_score += self.board.get_value(pos=ball.pos)

            # Update player score
            player.score = updated_score

        # Done =)
        return


if __name__ == "__main__":
    gm = GameManager()
    score_minimizer = gm.players[0].score
    score_maximizer = gm.players[1].score
    print(score_minimizer)
    print(score_maximizer)


def get_action_name(action_value):
    for action_name, value in action_dic.items():
        if value == action_value:
            return action_name


def get_player_name(player_value):
    for player_name, value in player_type_dic.items():
        if value == player_value:
            return player_name


class Node(object):
    def __init__(self, min_ball0, min_ball1, max_ball0, max_ball1, last_action, last_ball_moved, last_action_type,
                 depth, parent):

        # State Variables
        self.min_ball_scores = [min_ball0, min_ball1]
        self.max_ball_scores = [max_ball0, max_ball1]
        self.min_total_score = min_ball0 + min_ball1
        self.max_total_score = max_ball0 + max_ball1
        self.parent = parent
        self.last_action_type = last_action_type
        self.depth = depth
        self.children = []
        self.last_action = last_action
        self.last_ball_moved = last_ball_moved

    def addChild(self, child):
        self.children.append(child)  # this add a child to the children list

    def check_balls_position(self, new_node, action_type):

        # Check if both balls of new node are in the same position
        if action_type == player_type_dic['max']:
            if new_node.max_ball_scores[0] == new_node.max_ball_scores[1]:
                return False
            # if new_node.max_ball_scores[0] == self.min_ball_scores[0] or new_node.max_ball_scores[0] == self.min_ball_scores[1]:
            #  return False
            # elif new_node.max_ball_scores[1] == self.min_ball_scores[0] or new_node.max_ball_scores[1] == self.min_ball_scores[1]:
            #  return False
            else:
                return True
            # For each of the new node balls, check if its position is the same as any of the parents balls position
        if action_type == player_type_dic['min']:
            if new_node.min_ball_scores[0] == new_node.min_ball_scores[1]:
                return False
            # if new_node.min_ball_scores[0] == self.max_ball_scores[0] or new_node.min_ball_scores[0] == self.max_ball_scores[1]:
            #  return False
            # elif new_node.min_ball_scores[1] == self.max_ball_scores[0] or new_node.min_ball_scores[1] == self.max_ball_scores[1]:
            #  return False
            else:
                return True
        else:
            return True

    def expand(self, board, action_type):
        # For each ball we try all possible actions
        if action_type == player_type_dic['max']:

            for i in range(len(self.max_ball_scores)):
                # import pdb;pdb.set_trace()
                # Get position of ball from its score
                ball_pos = board.get_pos(value=self.max_ball_scores[i])

                # Lets try all action and check if they are valid
                for k in range(len(action_dic)):
                    ball = Ball(id=i, player_id=player_type_dic['max'], pos=ball_pos[:])
                    new_pos = ball.move(action=k)
                    # If the action is invalid, we forget it
                    if new_pos is None:
                        # print("Action is invalid")
                        continue
                    # If the action is valid, we create a child node
                    else:
                        new_ball_score = board.get_value(pos=new_pos)

                        if i == 0:

                            new_node = Node(min_ball0=self.min_ball_scores[0],
                                            min_ball1=self.min_ball_scores[1],
                                            max_ball0=new_ball_score,
                                            max_ball1=self.max_ball_scores[1],
                                            last_action=k,
                                            last_ball_moved=i,
                                            last_action_type=action_type,
                                            depth=self.depth + 1,
                                            parent=self)


                        else:

                            new_node = Node(min_ball0=self.min_ball_scores[0],
                                            min_ball1=self.min_ball_scores[1],
                                            max_ball0=self.max_ball_scores[0],
                                            max_ball1=new_ball_score,
                                            last_action=k,
                                            last_ball_moved=i,
                                            last_action_type=action_type,
                                            depth=self.depth + 1,
                                            parent=self)

                        # Check if the new node has both balls in the same position or in the parents balls position
                        if self.check_balls_position(new_node=new_node, action_type=action_type):
                            self.addChild(new_node)
                        else:
                            # Append new node to the children list
                            continue
            return
        if action_type == player_type_dic['min']:

            for i in range(len(self.min_ball_scores)):
                # import pdb;pdb.set_trace()
                # Get position of ball from its score
                ball_pos = board.get_pos(value=self.min_ball_scores[i])

                # Lets try all action and check if they are valid
                for k in range(len(action_dic)):
                    ball = Ball(id=i, player_id=player_type_dic['min'], pos=ball_pos[:])
                    new_pos = ball.move(action=k)
                    # If the action is invalid, we forget it
                    if new_pos is None:
                        # print("Action is invalid")
                        continue
                    # If the action is valid, we create a child node
                    else:
                        new_ball_score = board.get_value(pos=new_pos)

                        if i == 0:

                            new_node = Node(min_ball0=new_ball_score,
                                            min_ball1=self.min_ball_scores[1],
                                            max_ball0=self.max_ball_scores[0],
                                            max_ball1=self.max_ball_scores[1],
                                            last_action=k,
                                            last_ball_moved=i,
                                            last_action_type=action_type,
                                            depth=self.depth + 1,
                                            parent=self)


                        else:

                            new_node = Node(min_ball0=self.min_ball_scores[0],
                                            min_ball1=new_ball_score,
                                            max_ball0=self.max_ball_scores[0],
                                            max_ball1=self.max_ball_scores[1],
                                            last_action=k,
                                            last_ball_moved=i,
                                            last_action_type=action_type,
                                            depth=self.depth + 1,
                                            parent=self)

                        # Check if the new node has both balls in the same position or in the parents balls position
                        if self.check_balls_position(new_node=new_node, action_type=action_type):
                            self.addChild(new_node)
                        else:
                            # Append new node to the children list
                            continue

            return

        # if child_node.depth == 0 and action_type == player_type_dic['min']:
        #  for a in child_node.min_scores:
        #    ball.move(action=max(a))

    ### implement the expand


# class State(object):
# def _init_(self)


if __name__ == "__main__":

    board = Board()
    test_node = Node(min_ball0=200,
                     min_ball1=800,
                     max_ball0=1,
                     max_ball1=4,
                     last_action=None,
                     last_ball_moved=None,
                     last_action_type=None,
                     depth=0,
                     parent=None)

    test_node.expand(board=board, action_type=player_type_dic['min'])

    for child_node in test_node.children:
        # pdb.set_trace()
        print(" Child Node Info:")
        print(" -- Player Who Did the Action: " + str(get_player_name(child_node.last_action_type)))
        print(" -- Last Ball Moved: " + str(child_node.last_ball_moved))
        print(" -- Player Last Action: " + str(get_action_name(child_node.last_action)))
        print(" -- Max Total Score: " + str(child_node.max_total_score))
        print(" -- Min Total Score: " + str(child_node.min_total_score))
        print(" -- Max Ball 0 Score: " + str(child_node.max_ball_scores[0]) + " | Max Ball 0 Pos: " + str(
            board.get_pos(child_node.max_ball_scores[0])))
        print(" -- Max Ball 1 Score: " + str(child_node.max_ball_scores[1]) + " | Max Ball 1 Pos: " + str(
            board.get_pos(child_node.max_ball_scores[1])))
        print(" -- Min Ball 0 Score: " + str(child_node.min_ball_scores[0]) + " | Min Ball 0 Pos: " + str(
            board.get_pos(child_node.min_ball_scores[0])))
        print(" -- Min Ball 1 Score: " + str(child_node.min_ball_scores[1]) + " | Min Ball 0 Pos: " + str(
            board.get_pos(child_node.min_ball_scores[1])))


class Tree(object):
    def __init__(self, root, board):
        self.root = root
        self.openNodes = []
        self.openNodes.append(root)
        self.closeNodes = []
        self.board = board
        self.max_scores = []
        self.min_scores = []
        self.depth_max_nodes = []
        self.win_max_nodes = []
        self.win_min_nodes = []

    def populateTree(self, max_depth=1):
        while len(self.openNodes) != 0:

            # Pop first node in open Nodes List
            node = self.openNodes.pop(0)

            # Check if we can continue expansion
            if self.check_node_expansion(node, max_depth):

                if node.last_action_type == 0:
                    node.expand(board=self.board, action_type=1)
                else:
                    node.expand(board=self.board, action_type=0)

                # append the children of the node to the open nodes
                self.openNodes.extend(node.children)

                self.closeNodes.append(node)

            else:

                self.closeNodes.append(node)

    def check_node_expansion(self, node, max_depth):

        continue_expansion = True

        # Check if the game ended
        if node.min_total_score < node.max_total_score:
            continue_expansion = False

            # see who won
            if node.last_action_type == player_type_dic['max']:
                print(" -- Maximizer you WON! -- ")
                self.win_max_nodes.append(node)
            else:
                print(" -- Minimizer you WON! -- ")
                self.win_min_nodes.append(node)

        # Check if we reached maximum depth
        if node.depth >= max_depth:

            continue_expansion = False

            if node.depth == max_depth:
                self.depth_max_nodes.append(node)

        return continue_expansion

    def decide_best_action(self, player_type):

        best_node = None
        best_node_value = None

        # If the decision is for the max player, we want the node with the maximum value
        if player_type == player_type_dic['max']:

            # Iterate over the nodes and find the node with the maximum val()
            best_node_value = 0.0

            for node in self.depth_max_nodes:

                if node.max_total_score > best_node_value:
                    best_node = node
                    best_node_value = node.max_total_score
        # If the decision is for the max player, we want the node with the maximum value
        elif player_type == player_type_dic['min']:

            # pdb.set_trace()

            # Iterate over the nodes and find the node with the minimum value
            best_node_value = float('inf')

            for node in self.depth_max_nodes:

                if node.min_total_score < best_node_value:
                    best_node = node
                    best_node_value = node.min_total_score

        else:
            print("Error. Wrong player type selected")
            return

        # We need to go back to depth=1 to decide which is the best action
        node = best_node
        node_tree = []
        node_tree.append(node)
        while node.depth != 1:
            node = node.parent
            node_tree.append(node)

        # Now we have the node at depth = 1
        action_to_take = node.last_action
        ball_to_move = node.last_ball_moved

        # Print Tree
        self.print_tree(decision_type="Best", node_tree=node_tree)

    def decide_worst_action(self, player_type):

        worst_node = None
        worst_node_value = None

        # If the decision is for the max player, we want the node with the maximum value
        if player_type == player_type_dic['max']:

            # Iterate over the nodes and find the node with the maximum value
            worst_node_value = float('inf')

            for node in self.depth_max_nodes:

                if node.max_total_score < worst_node_value:
                    worst_node = node
                    worst_node_value = node.max_total_score
        # If the decision is for the max player, we want the node with the maximum value
        elif player_type == player_type_dic['min']:

            # pdb.set_trace()

            # Iterate over the nodes and find the node with the minimum value
            worst_node_value = 0.0

            for node in self.depth_max_nodes:

                if node.min_total_score > worst_node_value:
                    worst_node = node
                    worst_node_value = node.min_total_score

        else:
            print("Error. Wrong player type selected")
            return

        # We need to go back to depth=1 to decide which is the best action
        node = worst_node
        node_tree = []
        node_tree.append(node)
        while node.depth != 1:
            node = node.parent
            node_tree.append(node)

        # Now we have the node at depth = 1
        action_to_take = node.last_action
        ball_to_move = node.last_ball_moved

        # Print Tree
        self.print_tree(decision_type="Worst", node_tree=node_tree)

    def decide_random_action(self, player_type):

        # First copy the list of depth_max nodes
        new_depth_max_nodes = self.depth_max_nodes[:]

        # Pop the best and the worst nodes
        best_node_index = -1
        best_node_value = None
        worst_node_index = -1
        worst_node_value = None

        ###### FOR THE MAX PLAYER

        # If the decision is for the max player, we want the node with the maximum value
        if player_type == player_type_dic['max']:

            # Iterate over the nodes and find the node with the maximum value - BEST NODE to remove it from the random choices
            best_node_value = 0
            for i in range(len(new_depth_max_nodes)):

                if new_depth_max_nodes[i].max_total_score > best_node_value:
                    best_node_index = i
                    best_node_value = new_depth_max_nodes[i].max_total_score

            # Now we pop the max node out of the list
            _ = new_depth_max_nodes.pop(i)

            # Iterate over the nodes and find the node with the maximum value - WORST NODE
            worst_node_value = float('inf')
            for i in range(len(new_depth_max_nodes)):

                if new_depth_max_nodes[i].max_total_score < worst_node_value:
                    worst_node_index = i
                    worst_node_value = new_depth_max_nodes[i].max_total_score

            # Now we pop the max node out of the list
            _ = new_depth_max_nodes.pop(i)

            ##### NOW FOR THE MIN PLAYER

            # If the decision is for the max player, we want the node with the maximum value
        if player_type == player_type_dic['min']:

            # Iterate over the nodes and find the node with the maximum value - MAX NODE
            best_node_value = float('inf')
            for i in range(len(new_depth_max_nodes)):

                if new_depth_max_nodes[i].max_total_score < best_node_value:
                    best_node_index = i
                    best_node_value = new_depth_max_nodes[i].max_total_score

            # Now we pop the max node out of the list
            _ = new_depth_max_nodes.pop(i)

            # Iterate over the nodes and find the node with the maximum value - WORST NODE
            worst_node_value = float('inf')
            for i in range(len(new_depth_max_nodes)):

                if new_depth_max_nodes[i].max_total_score > worst_node_value:
                    worst_node_index = i
                    worst_node_value = new_depth_max_nodes[i].max_total_score

            # Now we pop the max node out of the list
            _ = new_depth_max_nodes.pop(i)

        else:
            print("Error. Wrong player type selected")

        # Randomly decide with node we want
        random_node = random.choice(new_depth_max_nodes)

        # We need to go back to depth=1 to decide which is the best action
        node = random_node

        node_tree = []
        node_tree.append(node)
        while node.depth != 1:
            node = node.parent
            node_tree.append(node)

        # Now we have the node at depth = 1
        action_to_take = node.last_action
        ball_to_move = node.last_ball_moved

        # Print Tree
        self.print_tree(decision_type="Random", node_tree=node_tree)

    def print_tree(self, decision_type, node_tree):

        print(" Tree for Decision Type = " + str(decision_type))

        for node in reversed(node_tree):
            print(" -- Depth: " + str(node.depth))
            print(" -- Player who did the action: " + str(get_player_name(node.last_action_type)))
            print(" -- Action to take: " + str(get_action_name(node.last_action)))
            print(" -- Ball to move: " + str(node.last_ball_moved))
            print(" -- Max Total Score: " + str(node.max_total_score))
            print(" -- Min Total Score: " + str(node.min_total_score))
            print(" -- Max Ball 0 Score: " + str(node.max_ball_scores[0]) + " | Max Ball 0 Pos: " + str(
                board.get_pos(node.max_ball_scores[0])))
            print(" -- Max Ball 1 Score: " + str(node.max_ball_scores[1]) + " | Max Ball 1 Pos: " + str(
                board.get_pos(node.max_ball_scores[1])))
            print(" -- Min Ball 0 Score: " + str(node.min_ball_scores[0]) + " | Min Ball 0 Pos: " + str(
                board.get_pos(node.min_ball_scores[0])))
            print(" -- Min Ball 1 Score: " + str(node.min_ball_scores[1]) + " | Min Ball 1 Pos: " + str(
                board.get_pos(node.min_ball_scores[1])))

        return


if __name__ == "__main__":
    board = Board()
    root_node = Node(min_ball0=20,
                     min_ball1=80,
                     max_ball0=10,
                     max_ball1=40,
                     last_action=None,
                     last_ball_moved=None,
                     last_action_type=None,
                     depth=0,
                     parent=None)

    tree = Tree(root=root_node, board=board)
    tree.populateTree(max_depth=1)

    # for child_node in tree.closeNodes:

    # tree.closeNodes.append(str(child_node.max_total_score))
    # print(" Closed Node Info:")
    # print(" -- Depth           : " + str(child_node.depth))
    # print(" -- Max Total Score : " + str(child_node.max_total_score))
    # print(" -- Min Total Score : " + str(child_node.min_total_score))
    # print(" -- Last Action Type: " + str(child_node.last_action_type))
    # print(" -- Max Ball 0 Score: " + str(child_node.max_ball_scores[0]) + " | Max Ball 0 Pos: " + str(board.get_pos(child_node.max_ball_scores[0])))
    # print(" -- Max Ball 1 Score: " + str(child_node.max_ball_scores[1]) + " | Max Ball 1 Pos: " + str(board.get_pos(child_node.max_ball_scores[1])))
    # print(" -- Min Ball 0 Score: " + str(child_node.min_ball_scores[0]) + " | Min Ball 0 Pos: " + str(board.get_pos(child_node.min_ball_scores[0])))
    # print(" -- Min Ball 1 Score: " + str(child_node.min_ball_scores[1]) + " | Min Ball 1 Pos: " + str(board.get_pos(child_node.min_ball_scores[1])))

    tree.decide_best_action(player_type=player_type_dic['min'])
    tree.decide_worst_action(player_type=player_type_dic['min'])
    tree.decide_random_action(player_type=player_type_dic['min'])
